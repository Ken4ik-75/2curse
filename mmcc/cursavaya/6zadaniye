# ------------------------
# Приложение 2
# Пункт 6: Вычисление нагрузки на линии связи
# ------------------------
import math

def reconstruct_path(i, j, next_node):
    """
    Если Вы сохраняете промежуточные узлы при Флойде,
    то в next_node[i][j] хранится следующий узел на пути i->j.
    Данная функция восстанавливает путь (список узлов).
    """
    if next_node[i][j] is None:
        return []
    path = [i]
    while i != j:
        i = next_node[i][j]
        path.append(i)
    return path

def compute_link_loads(n, traffic_matrix, next_node):
    """
    Для каждой пары (s, t) восстанавливаем путь, 
    и увеличиваем нагрузку Y_{s,t} на каждом рёбре.
    traffic_matrix: матрица Y_{s,t} (n x n).
    next_node: матрица для восстановления маршрута (n x n).
    Возвращаем словарь {(p,q): load_in_erlangs}.
    """
    link_load = {}
    for s in range(n):
        for t in range(n):
            if s != t:
                A_st = traffic_matrix[s][t]
                path_st = reconstruct_path(s, t, next_node)
                # Проходим по рёбрам пути
                for idx in range(len(path_st)-1):
                    p = path_st[idx]
                    q = path_st[idx+1]
                    link_load[(p,q)] = link_load.get((p,q), 0) + A_st
    return link_load

if __name__ == "__main__":
    # Размерность матрицы
    n = 20

    # Ваш список из 400 чисел (матрица 20x20 в виде "одномерного" списка)
    nums = [
      0.0, 26.9, 47.7, 65.9, 55.6, 51.2, 12.4, 8.6, 51.6, 61.8,
      70.1, 60.6, 56.1, 62.2, 44.9, 20.7, 62.5, 58.6, 24.6, 55.6,
      27.0, 0.0, 17.4, 24.1, 20.4, 18.8, 4.55, 3.16, 18.8, 22.7,
      25.6, 22.2, 21.0, 23.0, 16.4, 7.58, 23.0, 21.5, 9.0, 20.4,
      47.7, 17.4, 0.0, 42.7, 36.1, 33.2, 8.05, 5.59, 33.4, 40.1,
      45.4, 39.3, 36.3, 40.3, 28.9, 13.4, 40.6, 38.0, 15.9, 36.1,
      66.0, 24.1, 42.7, 0.0, 49.8, 45.8, 11.1, 7.84, 46.2, 55.4,
      62.7, 54.4, 50.2, 55.7, 40.2, 18.5, 55.9, 52.5, 21.9, 49.8,
      55.7, 20.4, 36.1, 49.8, 0.0, 38.7, 9.41, 6.54, 38.9, 46.8,
      52.9, 45.9, 42.5, 47.1, 34.0, 15.7, 47.3, 44.3, 18.6, 0.0,
      51.2, 18.8, 33.2, 45.8, 38.7, 0.0, 8.63, 6.01, 35.9, 43.0,
      48.7, 42.3, 39.0, 42.9, 31.2, 14.4, 43.2, 40.6, 16.9, 38.7,
      12.4, 4.55, 8.05, 11.1, 9.41, 8.63, 0.0, 1.45, 8.70, 10.4,
      11.8, 10.6, 9.46, 10.5, 7.56, 3.48, 10.5, 9.88, 4.14, 9.41,
      8.69, 3.16, 5.59, 7.84, 6.54, 6.01, 1.45, 0.0, 6.06, 7.24,
      8.23, 7.29, 6.51, 7.22, 5.20, 2.39, 7.24, 6.82, 2.86, 6.54,
      51.6, 18.8, 33.4, 46.2, 38.9, 35.9, 8.70, 6.06, 0.0, 43.4,
      49.0, 42.5, 39.3, 43.5, 31.4, 14.5, 43.7, 40.9, 17.1, 39.3,
      61.8, 22.7, 40.1, 55.4, 46.8, 43.0, 10.4, 7.24, 43.4, 0.0,
      58.8, 51.1, 47.3, 52.3, 37.7, 17.4, 52.5, 49.3, 20.6, 46.8,
      70.1, 25.6, 45.4, 62.7, 52.9, 48.7, 11.8, 8.23, 49.0, 58.8,
      0.0, 58.0, 53.4, 59.3, 42.7, 19.7, 59.4, 55.8, 23.4, 52.9,
      60.6, 22.2, 39.3, 54.4, 45.9, 42.3, 10.6, 7.29, 42.5, 51.1,
      58.0, 0.0, 51.8, 57.5, 41.4, 19.1, 57.6, 54.2, 22.7, 45.9,
      56.1, 21.0, 36.3, 50.2, 42.5, 39.0, 9.46, 6.51, 39.3, 47.3,
      53.4, 51.8, 0.0, 54.4, 34.2, 15.8, 54.6, 51.1, 21.4, 42.5,
      64.1, 23.0, 40.3, 55.7, 47.1, 42.9, 10.5, 7.22, 43.5, 52.3,
      59.3, 57.5, 54.4, 0.0, 39.0, 18.0, 59.1, 55.5, 23.2, 47.1,
      46.2, 16.4, 28.9, 40.2, 34.0, 31.2, 7.56, 5.20, 31.4, 37.7,
      42.7, 41.4, 34.2, 39.0, 0.0, 12.6, 39.1, 36.9, 15.0, 34.0,
      20.7, 7.58, 13.4, 18.5, 15.7, 14.4, 3.48, 2.39, 14.5, 17.4,
      19.7, 19.1, 15.8, 18.0, 12.6, 0.0, 18.1, 17.1, 7.0, 15.7,
      62.5, 23.0, 40.6, 55.9, 47.3, 43.2, 10.5, 7.24, 43.7, 52.5,
      59.4, 57.6, 54.6, 59.1, 39.1, 18.1, 0.0, 57.2, 23.9, 47.3,
      58.6, 21.5, 38.0, 52.5, 44.3, 40.6, 9.88, 6.82, 40.9, 49.3,
      55.8, 54.2, 51.1, 55.5, 36.9, 17.1, 57.2, 0.0, 22.0, 44.3,
      24.6, 9.0, 15.9, 21.9, 18.6, 16.9, 4.14, 2.86, 17.1, 20.6,
      23.4, 22.7, 21.4, 23.2, 15.0, 7.0, 23.9, 22.0, 0.0, 18.6,
      55.6, 20.4, 36.1, 49.8, 0.0, 38.7, 9.41, 6.54, 39.3, 46.8,
      52.9, 45.9, 42.5, 47.1, 34.0, 15.7, 47.3, 44.3, 18.6, 0.0
    ]

    # Превращаем список nums в матрицу 20x20
    Y_ij = []
    k = 0
    for i in range(n):
        row = []
        for j in range(n):
            row.append(nums[k])
            k += 1
        Y_ij.append(row)

    # Выведем матрицу в «табличном» виде (для отчёта)
    print("Матрица Y_ij (20x20):")
    for i in range(n):
        # Пример: печатать каждый элемент с 2 знаками после запятой
        row_str = " ".join(f"{Y_ij[i][j]:7.2f}" for j in range(n))
        print(row_str)

    # Считаем контрольную сумму элементов матрицы
    control_sum = sum(sum(row) for row in Y_ij)
    print(f"\nКонтрольная сумма матрицы Y_ij = {control_sum:.2f}\n")

    # Для упрощения: считаем, что путь i->j напрямую (без промежуточных узлов)
    next_node = [[None]*n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if i != j:
                next_node[i][j] = j

    # Считаем нагрузку
    loads = compute_link_loads(n, Y_ij, next_node)
    print("Нагрузка на рёбрах (link_load):")
    for edge, val in loads.items():
        print(f"{edge}: {val:.2f} Эрл")